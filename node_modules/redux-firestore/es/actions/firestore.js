"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.set = set;
exports.get = get;
exports.update = update;
exports.deleteRef = deleteRef;
exports.setListener = setListener;
exports.setListeners = setListeners;
exports.unsetListener = unsetListener;
exports.unsetListeners = unsetListeners;
exports.runTransaction = runTransaction;
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _every2 = _interopRequireDefault(require("lodash/every"));

var _isFunction2 = _interopRequireDefault(require("lodash/isFunction"));

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _actions = require("../utils/actions");

var _constants = require("../constants");

var _query = require("../utils/query");

var _async = require("../utils/async");

var pathListenerCounts = {};

function add(firebase, dispatch, queryOption) {
  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    args[_key - 3] = arguments[_key];
  }

  var meta = (0, _query.getQueryConfig)(queryOption);
  return (0, _actions.wrapInDispatch)(dispatch, {
    ref: (0, _query.firestoreRef)(firebase, meta),
    method: 'add',
    meta: meta,
    args: args,
    types: [_constants.actionTypes.ADD_REQUEST, {
      type: _constants.actionTypes.ADD_SUCCESS,
      payload: function payload(snap) {
        return {
          id: snap.id,
          data: args[0]
        };
      }
    }, _constants.actionTypes.ADD_FAILURE]
  });
}

function set(firebase, dispatch, queryOption) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    args[_key2 - 3] = arguments[_key2];
  }

  var meta = (0, _query.getQueryConfig)(queryOption);
  return (0, _actions.wrapInDispatch)(dispatch, {
    ref: (0, _query.firestoreRef)(firebase, meta),
    method: 'set',
    meta: meta,
    args: args,
    types: [_constants.actionTypes.SET_REQUEST, _constants.actionTypes.SET_SUCCESS, _constants.actionTypes.SET_FAILURE]
  });
}

function get(firebase, dispatch, queryOption) {
  var meta = (0, _query.getQueryConfig)(queryOption);

  var _ref = firebase._.config || {},
      mergeOrdered = _ref.mergeOrdered,
      mergeOrderedDocUpdates = _ref.mergeOrderedDocUpdates,
      mergeOrderedCollectionUpdates = _ref.mergeOrderedCollectionUpdates;

  return (0, _actions.wrapInDispatch)(dispatch, {
    ref: (0, _query.firestoreRef)(firebase, meta),
    method: 'get',
    meta: meta,
    types: [_constants.actionTypes.GET_REQUEST, {
      type: _constants.actionTypes.GET_SUCCESS,
      payload: function payload(snap) {
        return {
          data: (0, _query.dataByIdSnapshot)(snap),
          ordered: (0, _query.orderedFromSnap)(snap)
        };
      },
      merge: {
        docs: mergeOrdered && mergeOrderedDocUpdates,
        collections: mergeOrdered && mergeOrderedCollectionUpdates
      }
    }, _constants.actionTypes.GET_FAILURE]
  });
}

function update(firebase, dispatch, queryOption) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
    args[_key3 - 3] = arguments[_key3];
  }

  var meta = (0, _query.getQueryConfig)(queryOption);
  return (0, _actions.wrapInDispatch)(dispatch, {
    ref: (0, _query.firestoreRef)(firebase, meta),
    method: 'update',
    meta: meta,
    args: args,
    types: [_constants.actionTypes.UPDATE_REQUEST, _constants.actionTypes.UPDATE_SUCCESS, _constants.actionTypes.UPDATE_FAILURE]
  });
}

function deleteRef(firebase, dispatch, queryOption) {
  var meta = (0, _query.getQueryConfig)(queryOption);
  var config = firebase._.config;

  if (!meta.doc || meta.subcollections && !(0, _every2.default)(meta.subcollections, 'doc')) {
    if ((0, _isFunction2.default)(config.onAttemptCollectionDelete)) {
      return config.onAttemptCollectionDelete(queryOption, dispatch, firebase);
    }

    return Promise.reject(new Error('Only documents can be deleted.'));
  }

  return (0, _actions.wrapInDispatch)(dispatch, {
    ref: (0, _query.firestoreRef)(firebase, meta),
    method: 'delete',
    meta: meta,
    types: [_constants.actionTypes.DELETE_REQUEST, {
      type: _constants.actionTypes.DELETE_SUCCESS,
      preserve: firebase._.config.preserveOnDelete
    }, _constants.actionTypes.DELETE_FAILURE]
  });
}

function setListener(firebase, dispatch, queryOpts, successCb, errorCb) {
  var meta = (0, _query.getQueryConfig)(queryOpts);
  var unsubscribe = (0, _query.firestoreRef)(firebase, meta).onSnapshot(function () {
    var _ref2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(docData) {
      var _ref3, _ref4, populateErr, populateActions;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (meta.populates) {
                _context.next = 4;
                break;
              }

              (0, _query.dispatchListenerResponse)({
                dispatch: dispatch,
                docData: docData,
                meta: meta,
                firebase: firebase
              });
              if (typeof successCb === 'function') successCb(docData);
              return _context.abrupt("return");

            case 4:
              _context.next = 6;
              return (0, _async.to)((0, _query.getPopulateActions)({
                firebase: firebase,
                docData: docData,
                meta: meta
              }));

            case 6:
              _ref3 = _context.sent;
              _ref4 = (0, _slicedToArray2.default)(_ref3, 2);
              populateErr = _ref4[0];
              populateActions = _ref4[1];

              if (!populateErr) {
                _context.next = 14;
                break;
              }

              if (firebase._.config.logListenerError) {
                (0, _invoke2.default)(console, 'error', "Error populating:", populateErr);
              }

              if (typeof errorCb === 'function') errorCb(populateErr);
              return _context.abrupt("return");

            case 14:
              populateActions.forEach(function (populateAction) {
                dispatch((0, _objectSpread2.default)({}, populateAction, {
                  type: _constants.actionTypes.LISTENER_RESPONSE,
                  timestamp: Date.now()
                }));
              });
              (0, _query.dispatchListenerResponse)({
                dispatch: dispatch,
                docData: docData,
                meta: meta,
                firebase: firebase
              });

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }(), function (err) {
    var _ref5 = firebase._.config || {},
        mergeOrdered = _ref5.mergeOrdered,
        mergeOrderedDocUpdates = _ref5.mergeOrderedDocUpdates,
        mergeOrderedCollectionUpdates = _ref5.mergeOrderedCollectionUpdates;

    var _ref6 = firebase._.config || {},
        logListenerError = _ref6.logListenerError,
        preserveOnListenerError = _ref6.preserveOnListenerError;

    if (logListenerError) (0, _invoke2.default)(console, 'error', err);
    dispatch({
      type: _constants.actionTypes.LISTENER_ERROR,
      meta: meta,
      payload: err,
      merge: {
        docs: mergeOrdered && mergeOrderedDocUpdates,
        collections: mergeOrdered && mergeOrderedCollectionUpdates
      },
      preserve: preserveOnListenerError
    });
    if (typeof errorCb === 'function') errorCb(err);
  });
  (0, _query.attachListener)(firebase, dispatch, meta, unsubscribe);
  return unsubscribe;
}

function setListeners(firebase, dispatch, listeners) {
  if (!(0, _isArray2.default)(listeners)) {
    throw new Error('Listeners must be an Array of listener configs (Strings/Objects).');
  }

  var config = firebase._.config;
  var allowMultipleListeners = config.allowMultipleListeners;
  return listeners.forEach(function (listener) {
    var path = (0, _query.getQueryName)(listener);
    var oldListenerCount = pathListenerCounts[path] || 0;
    var multipleListenersEnabled = (0, _isFunction2.default)(allowMultipleListeners) ? allowMultipleListeners(listener, firebase._.listeners) : allowMultipleListeners;
    pathListenerCounts[path] = oldListenerCount + 1;

    if (oldListenerCount === 0 || multipleListenersEnabled) {
      setListener(firebase, dispatch, listener);
    }
  });
}

function unsetListener(firebase, dispatch, opts) {
  return (0, _query.detachListener)(firebase, dispatch, (0, _query.getQueryConfig)(opts));
}

function unsetListeners(firebase, dispatch, listeners) {
  if (!(0, _isArray2.default)(listeners)) {
    throw new Error('Listeners must be an Array of listener configs (Strings/Objects).');
  }

  var config = firebase._.config;
  var allowMultipleListeners = config.allowMultipleListeners;
  listeners.forEach(function (listener) {
    var path = (0, _query.getQueryName)(listener);
    var listenerExists = pathListenerCounts[path] >= 1;
    var multipleListenersEnabled = (0, _isFunction2.default)(allowMultipleListeners) ? allowMultipleListeners(listener, firebase._.listeners) : allowMultipleListeners;

    if (listenerExists) {
      pathListenerCounts[path] -= 1;

      if (pathListenerCounts[path] === 0 || multipleListenersEnabled) {
        unsetListener(firebase, dispatch, listener);
      }
    }
  });
}

function runTransaction(firebase, dispatch, transactionPromise) {
  return (0, _actions.wrapInDispatch)(dispatch, {
    ref: firebase.firestore(),
    method: 'runTransaction',
    args: [transactionPromise],
    types: [_constants.actionTypes.TRANSACTION_START, _constants.actionTypes.TRANSACTION_SUCCESS, _constants.actionTypes.TRANSACTION_FAILURE]
  });
}

var _default = {
  get: get,
  firestoreRef: _query.firestoreRef,
  add: add,
  update: update,
  setListener: setListener,
  setListeners: setListeners,
  unsetListener: unsetListener,
  unsetListeners: unsetListeners,
  runTransaction: runTransaction
};
exports.default = _default;