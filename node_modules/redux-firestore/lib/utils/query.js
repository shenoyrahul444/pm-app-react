"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.firestoreRef = firestoreRef;
exports.getQueryName = getQueryName;
exports.getBaseQueryName = getBaseQueryName;
exports.listenerExists = listenerExists;
exports.attachListener = attachListener;
exports.detachListener = detachListener;
exports.queryStrToObj = queryStrToObj;
exports.getQueryConfig = getQueryConfig;
exports.getQueryConfigs = getQueryConfigs;
exports.orderedFromSnap = orderedFromSnap;
exports.dataByIdSnapshot = dataByIdSnapshot;
exports.getPopulateChild = getPopulateChild;
exports.populateList = populateList;
exports.promisesForPopulate = promisesForPopulate;
exports.dispatchListenerResponse = dispatchListenerResponse;
exports.getPopulateActions = getPopulateActions;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _some2 = _interopRequireDefault(require("lodash/some"));

var _set2 = _interopRequireDefault(require("lodash/set"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _has2 = _interopRequireDefault(require("lodash/has"));

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _trim2 = _interopRequireDefault(require("lodash/trim"));

var _size2 = _interopRequireDefault(require("lodash/size"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _isFunction2 = _interopRequireDefault(require("lodash/isFunction"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _async = require("../utils/async");

var _constants = require("../constants");

function addWhereToRef(ref, where) {
  if (!(0, _isArray2.default)(where)) {
    throw new Error('where parameter must be an array.');
  }

  if ((0, _isString2.default)(where[0])) {
    return where.length > 1 ? ref.where.apply(ref, (0, _toConsumableArray2.default)(where)) : ref.where(where[0]);
  }

  return where.reduce(function (acc, whereArgs) {
    return addWhereToRef(acc, whereArgs);
  }, ref);
}

function addOrderByToRef(ref, orderBy) {
  if (!(0, _isArray2.default)(orderBy) && !(0, _isString2.default)(orderBy)) {
    throw new Error('orderBy parameter must be an array or string.');
  }

  if ((0, _isString2.default)(orderBy)) {
    return ref.orderBy(orderBy);
  }

  if ((0, _isString2.default)(orderBy[0])) {
    return ref.orderBy.apply(ref, (0, _toConsumableArray2.default)(orderBy));
  }

  return orderBy.reduce(function (acc, orderByArgs) {
    return addOrderByToRef(acc, orderByArgs);
  }, ref);
}

function handleSubcollections(ref, subcollectionList) {
  if (subcollectionList) {
    (0, _forEach2.default)(subcollectionList, function (subcollection) {
      if (subcollection.collection) {
        if (!(0, _isFunction2.default)(ref.collection)) {
          throw new Error("Collection can only be run on a document. Check that query config for subcollection: \"".concat(subcollection.collection, "\" contains a doc parameter."));
        }

        ref = ref.collection(subcollection.collection);
      }

      if (subcollection.doc) ref = ref.doc(subcollection.doc);
      if (subcollection.where) ref = addWhereToRef(ref, subcollection.where);

      if (subcollection.orderBy) {
        ref = addOrderByToRef(ref, subcollection.orderBy);
      }

      if (subcollection.limit) ref = ref.limit(subcollection.limit);
      if (subcollection.startAt) ref = ref.startAt(subcollection.startAt);

      if (subcollection.startAfter) {
        ref = ref.startAfter(subcollection.startAfter);
      }

      if (subcollection.endAt) ref = ref.endAt(subcollection.endAt);
      if (subcollection.endBefore) ref = ref.endBefore(subcollection.endBefore);
      ref = handleSubcollections(ref, subcollection.subcollections);
    });
  }

  return ref;
}

function firestoreRef(firebase, meta) {
  if (!firebase.firestore) {
    throw new Error('Firestore must be required and initalized.');
  }

  var collection = meta.collection,
      doc = meta.doc,
      subcollections = meta.subcollections,
      where = meta.where,
      orderBy = meta.orderBy,
      limit = meta.limit,
      startAt = meta.startAt,
      startAfter = meta.startAfter,
      endAt = meta.endAt,
      endBefore = meta.endBefore;
  var ref = firebase.firestore().collection(collection);
  if (doc) ref = ref.doc(doc);
  ref = handleSubcollections(ref, subcollections);
  if (where) ref = addWhereToRef(ref, where);
  if (orderBy) ref = addOrderByToRef(ref, orderBy);
  if (limit) ref = ref.limit(limit);
  if (startAt) ref = ref.startAt(startAt);
  if (startAfter) ref = ref.startAfter(startAfter);
  if (endAt) ref = ref.endAt(endAt);
  if (endBefore) ref = ref.endBefore(endBefore);
  return ref;
}

function whereToStr(where) {
  return (0, _isString2.default)(where[0]) ? "where=".concat(where.join(':')) : where.map(whereToStr);
}

function getQueryName(meta) {
  if ((0, _isString2.default)(meta)) {
    return meta;
  }

  var collection = meta.collection,
      doc = meta.doc,
      subcollections = meta.subcollections,
      where = meta.where,
      limit = meta.limit;

  if (!collection) {
    throw new Error('Collection is required to build query name');
  }

  var basePath = collection;

  if (doc) {
    basePath = basePath.concat("/".concat(doc));
  }

  if (subcollections) {
    var mappedCollections = subcollections.map(function (subcollection) {
      return getQueryName(subcollection);
    });
    basePath = "".concat(basePath, "/").concat(mappedCollections.join('/'));
  }

  if (where) {
    if (!(0, _isArray2.default)(where)) {
      throw new Error('where parameter must be an array.');
    }

    basePath = basePath.concat("?".concat(whereToStr(where)));
  }

  if (typeof limit !== 'undefined') {
    var limitStr = "limit=".concat(limit);
    basePath = basePath.concat("".concat(where ? '&' : '?').concat(limitStr));
  }

  return basePath;
}

function getBaseQueryName(meta) {
  if ((0, _isString2.default)(meta)) {
    return meta;
  }

  var collection = meta.collection,
      subcollections = meta.subcollections,
      where = meta.where,
      limit = meta.limit;

  if (!collection) {
    throw new Error('Collection is required to build query name');
  }

  var basePath = collection;

  if (subcollections) {
    var mappedCollections = subcollections.map(function (subcollection) {
      return getQueryName(subcollection);
    });
    basePath = "".concat(basePath, "/").concat(mappedCollections.join('/'));
  }

  if (where) {
    if (!(0, _isArray2.default)(where)) {
      throw new Error('where parameter must be an array.');
    }

    basePath = basePath.concat("?".concat(whereToStr(where)));
  }

  if (typeof limit !== 'undefined') {
    var limitStr = "limit=".concat(limit);
    basePath = basePath.concat("".concat(where ? '&' : '?').concat(limitStr));
  }

  return basePath;
}

function confirmMetaAndConfig(firebase, meta) {
  if (!meta) {
    throw new Error('Meta data is required to attach listener.');
  }

  if (!(0, _has2.default)(firebase, '_.listeners')) {
    throw new Error('Internal Firebase object required to attach listener. Confirm that reduxFirestore enhancer was added when you were creating your store');
  }
}

function listenerExists(firebase, meta) {
  confirmMetaAndConfig(firebase, meta);
  var name = getQueryName(meta);
  return !!firebase._.listeners[name];
}

function attachListener(firebase, dispatch, meta, unsubscribe) {
  confirmMetaAndConfig(firebase, meta);
  var name = getQueryName(meta);

  if (!firebase._.listeners[name]) {
    firebase._.listeners[name] = unsubscribe;
  }

  dispatch({
    type: _constants.actionTypes.SET_LISTENER,
    meta: meta,
    payload: {
      name: name
    }
  });
  return firebase._.listeners;
}

function detachListener(firebase, dispatch, meta) {
  var name = getQueryName(meta);

  if (firebase._.listeners[name]) {
    firebase._.listeners[name]();

    delete firebase._.listeners[name];
  }

  dispatch({
    type: _constants.actionTypes.UNSET_LISTENER,
    meta: meta,
    payload: {
      name: name
    }
  });
}

function queryStrToObj(queryPathStr, parsedPath) {
  var pathArr = parsedPath || (0, _trim2.default)(queryPathStr, ['/']).split('/');

  var _pathArr = (0, _toArray2.default)(pathArr),
      collection = _pathArr[0],
      doc = _pathArr[1],
      subcollections = _pathArr.slice(2);

  var queryObj = {};
  if (collection) queryObj.collection = collection;
  if (doc) queryObj.doc = doc;

  if (subcollections.length) {
    queryObj.subcollections = [queryStrToObj('', subcollections)];
  }

  return queryObj;
}

function getQueryConfig(query) {
  if ((0, _isString2.default)(query)) {
    return queryStrToObj(query);
  }

  if ((0, _isObject2.default)(query)) {
    if (!query.collection && !query.doc) {
      throw new Error('Collection and/or Doc are required parameters within query definition object.');
    }

    return query;
  }

  throw new Error('Invalid Path Definition: Only Strings and Objects are accepted.');
}

function getQueryConfigs(queries) {
  if ((0, _isArray2.default)(queries)) {
    return queries.map(getQueryConfig);
  }

  if ((0, _isString2.default)(queries)) {
    return queryStrToObj(queries);
  }

  if ((0, _isObject2.default)(queries)) {
    return [getQueryConfig(queries)];
  }

  throw new Error('Querie(s) must be an Array or a string.');
}

function orderedFromSnap(snap) {
  var ordered = [];

  if (snap.data && snap.exists) {
    var obj = (0, _isObject2.default)(snap.data()) ? (0, _objectSpread2.default)({
      id: snap.id
    }, snap.data() || snap.data) : {
      id: snap.id,
      data: snap.data()
    };
    ordered.push(obj);
  } else if (snap.forEach) {
    snap.forEach(function (doc) {
      var obj = (0, _isObject2.default)(doc.data()) ? (0, _objectSpread2.default)({
        id: doc.id
      }, doc.data() || doc.data) : {
        id: doc.id,
        data: doc.data()
      };
      ordered.push(obj);
    });
  }

  return ordered;
}

function dataByIdSnapshot(snap) {
  var data = {};

  if (snap.data && snap.exists) {
    data[snap.id] = snap.data();
  } else if (snap.forEach) {
    snap.forEach(function (doc) {
      data[doc.id] = doc.data() || doc;
    });
  }

  return (0, _size2.default)(data) ? data : null;
}

function getPopulateChild(firebase, populate, id) {
  return firestoreRef(firebase, {
    collection: populate.root,
    doc: id
  }).get().then(function (snap) {
    return snap.data();
  });
}

function populateList(firebase, list, p, results) {
  if (!results[p.root]) {
    (0, _set2.default)(results, p.root, {});
  }

  return Promise.all((0, _map2.default)(list, function (id, childKey) {
    var populateKey = id === true || p.populateByKey ? childKey : id;
    return getPopulateChild(firebase, p, populateKey).then(function (pc) {
      if (pc) {
        return (0, _set2.default)(results, "".concat(p.root, ".").concat(populateKey), pc);
      }

      return results;
    });
  }));
}

function getPopulateObj(str) {
  if (!(0, _isString2.default)(str)) {
    return str;
  }

  var strArray = str.split(':');
  return {
    child: strArray[0],
    root: strArray[1]
  };
}

function getPopulateObjs(arr) {
  if (!(0, _isArray2.default)(arr)) {
    return arr;
  }

  return arr.map(function (o) {
    return (0, _isObject2.default)(o) ? o : getPopulateObj(o);
  });
}

function promisesForPopulate(firebase, dataKey, originalData, populatesIn) {
  var promisesArray = [];
  var results = {};
  var populatesForData = getPopulateObjs((0, _isFunction2.default)(populatesIn) ? populatesIn(dataKey, originalData) : populatesIn);
  var dataHasPopulateChilds = (0, _some2.default)(populatesForData, function (populate) {
    return (0, _has2.default)(originalData, populate.child);
  });

  if (dataHasPopulateChilds) {
    (0, _forEach2.default)(populatesForData, function (p) {
      if ((0, _isString2.default)((0, _get2.default)(originalData, p.child))) {
        return promisesArray.push(getPopulateChild(firebase, p, (0, _get2.default)(originalData, p.child)).then(function (v) {
          if (v) {
            (0, _set2.default)(results, "".concat(p.root, ".").concat((0, _get2.default)(originalData, p.child)), v);
          }
        }));
      }

      return promisesArray.push(populateList(firebase, (0, _get2.default)(originalData, p.child), p, results));
    });
  } else {
    (0, _forEach2.default)(originalData, function (d, key) {
      var populatesForDataItem = getPopulateObj((0, _isFunction2.default)(populatesIn) ? populatesIn(key, d) : populatesIn);
      (0, _forEach2.default)(populatesForDataItem, function (p) {
        var idOrList = (0, _get2.default)(d, p.child);

        if (!idOrList) {
          return;
        }

        if ((0, _isString2.default)(idOrList)) {
          return promisesArray.push(getPopulateChild(firebase, p, idOrList).then(function (v) {
            if (v) {
              (0, _set2.default)(results, "".concat(p.root, ".").concat(idOrList), v);
            }

            return results;
          }));
        }

        if ((0, _isArray2.default)(idOrList) || (0, _isObject2.default)(idOrList)) {
          return promisesArray.push(populateList(firebase, idOrList, p, results));
        }
      });
    });
  }

  return Promise.all(promisesArray).then(function () {
    return results;
  });
}

var changeTypeToEventType = {
  added: _constants.actionTypes.DOCUMENT_ADDED,
  removed: _constants.actionTypes.DOCUMENT_REMOVED,
  modified: _constants.actionTypes.DOCUMENT_MODIFIED
};

function docChangeEvent(change) {
  var originalMeta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var meta = (0, _objectSpread2.default)({}, originalMeta, {
    path: change.doc.ref.path
  });

  if (originalMeta.subcollections && !originalMeta.storeAs) {
    meta.subcollections[0] = (0, _objectSpread2.default)({}, meta.subcollections[0], {
      doc: change.doc.id
    });
  } else {
    meta.doc = change.doc.id;
  }

  return {
    type: changeTypeToEventType[change.type] || _constants.actionTypes.DOCUMENT_MODIFIED,
    meta: meta,
    payload: {
      data: change.doc.data(),
      ordered: {
        oldIndex: change.oldIndex,
        newIndex: change.newIndex
      }
    }
  };
}

function dispatchListenerResponse(_ref) {
  var dispatch = _ref.dispatch,
      docData = _ref.docData,
      meta = _ref.meta,
      firebase = _ref.firebase;

  var _ref2 = firebase._.config || {},
      mergeOrdered = _ref2.mergeOrdered,
      mergeOrderedDocUpdates = _ref2.mergeOrderedDocUpdates,
      mergeOrderedCollectionUpdates = _ref2.mergeOrderedCollectionUpdates;

  var docChanges = typeof docData.docChanges === 'function' ? docData.docChanges() : docData.docChanges;

  if (docChanges && docChanges.length < docData.size) {
    docChanges.forEach(function (change) {
      dispatch(docChangeEvent(change, meta));
    });
  } else {
    dispatch({
      type: _constants.actionTypes.LISTENER_RESPONSE,
      meta: meta,
      payload: {
        data: dataByIdSnapshot(docData),
        ordered: orderedFromSnap(docData)
      },
      merge: {
        docs: mergeOrdered && mergeOrderedDocUpdates,
        collections: mergeOrdered && mergeOrderedCollectionUpdates
      }
    });
  }
}

function getPopulateActions(_x) {
  return _getPopulateActions.apply(this, arguments);
}

function _getPopulateActions() {
  _getPopulateActions = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(_ref3) {
    var firebase, docData, meta, _ref4, _ref5, populateErr, populateResults;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            firebase = _ref3.firebase, docData = _ref3.docData, meta = _ref3.meta;
            _context.next = 3;
            return (0, _async.to)(promisesForPopulate(firebase, docData.id, dataByIdSnapshot(docData), meta.populates));

          case 3:
            _ref4 = _context.sent;
            _ref5 = (0, _slicedToArray2.default)(_ref4, 2);
            populateErr = _ref5[0];
            populateResults = _ref5[1];

            if (!populateErr) {
              _context.next = 10;
              break;
            }

            console.error('Error with populate:', populateErr, meta);
            throw populateErr;

          case 10:
            return _context.abrupt("return", Object.keys(populateResults).map(function (resultKey) {
              return {
                meta: {
                  collection: resultKey
                },
                payload: {
                  data: populateResults[resultKey]
                },
                requesting: false,
                requested: true
              };
            }));

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _getPopulateActions.apply(this, arguments);
}